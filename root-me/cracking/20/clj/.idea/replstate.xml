<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456487748817">{:repl-history {:ide [], :local [&quot;(map #(count (second %)) soltest)&quot; &quot;(map first soltest)&quot; &quot;(map first sol1)&quot; &quot;(def sol1 (find-key (nth code-refs 1) soltest))&quot; &quot;(def sol0 (find-key (nth code-refs 0) sol1))&quot; &quot;(map #(count (second %)) sol0)&quot; &quot;(count sol1)&quot; &quot;(map #(count (second %)) sol1)&quot; &quot;sol1&quot; &quot;(map #([(first %) (count (second %))]) sol1)&quot; &quot;(map #(vector (first %) (count (second %))) sol1)&quot; &quot;(map #(vector (first %) (count (second %))) sol0)&quot; &quot;(def sol2 (find-key (nth code-refs 2)))&quot; &quot;(map #(vector (first %) (count (second %))) sol2)&quot; &quot;(def sol02 (find-key-at-pos p0 0 comb))&quot; &quot;(map #(vector (first %) (count (second %))) sol02)&quot; &quot;(count sol00)&quot; &quot;(def sol00 (find-key-at-pos p0 0 sol01))&quot; &quot;sol00&quot; &quot;(map char sol00)&quot; &quot;(map #(map char %) sol00)&quot; &quot;(def sol01 (find-key-at-pos p1 0 sol02))&quot; &quot;(count sol01)&quot; &quot;(def comb (combinations 3))&quot; &quot;(count comb)&quot; &quot;(def sol02 (find-key-at-pos p2 0 comb))&quot; &quot;(count sol02)&quot; &quot;(unsigned8 -2)&quot; &quot;(take 12 (flatten (repeat [1 2 4])))&quot; &quot;(brute-force code-refs 1)&quot; &quot;(brute-force code-refs 2)&quot; &quot;(brute-force code-refs 3)&quot; &quot;(brute-force code-refs 4)&quot; &quot;(map identity)&quot; &quot;(brute-force2 code-refs 2)&quot; &quot;(int (/ 3 2))&quot; &quot;\n(/ 3 2)&quot; &quot;\n(/ 5 3)&quot; &quot;(int (/ 5 3))&quot; &quot;(int 0.99)&quot; &quot;(round 0.99)&quot; &quot;(doall (try-key-at-pos p0 0 [32]))&quot; &quot;(try-key-at-pos p0 0 [32])&quot; &quot;(bytes-at-pos 0 (:data p0))&quot; &quot;(map hex (bytes-at-pos 0 (:data p0)))&quot; &quot;(map hex (bytes-at-pos 0xC (:data p0)))&quot; &quot;(map hex (bytes-at-pos 0xB (:data p0)))&quot; &quot;(/ 0x2D80 0xC)&quot; &quot;(/ 0x24 0xC)&quot; &quot;(/ 0x7d5c 0xC)&quot; &quot;(take 3 (flatten (repeat [32])))&quot; &quot;(try-key-at-pos p2 0 [32])&quot; &quot;(for [possible-key (combinations 43)]\n  (try-key-at-pos p2 0 possible-key))&quot; &quot;(partition 8 (range 0 110))&quot; &quot;(pmap identity (partition 8 (range 0 110)))&quot; &quot;(pmap #(+ 2) (partition 8 (range 0 110)))&quot; &quot;(pmap #(+ 2 %) (partition 8 (range 0 110)))&quot; &quot;(apply pmap #(+ 2 %) (partition 8 (range 0 110)))&quot; &quot;(pmap #(+ 2 %) [1 2] [2 3])&quot; &quot;(pmap #(+ 2 %)  [2 3])&quot; &quot;(crack-at-pos p0 0)&quot; &quot;(print \&quot;foo\&quot;)&quot; &quot;(defn crack-p-at-pos [{:keys [data length magic] :as code-ref} key-pos]\n  (let [xs-at-pos (bytes-at-pos key-pos data)\n        _ (println xs-at-pos)))&quot; &quot;(defn crack-p-at-pos [{:keys [data length magic] :as code-ref} key-pos]\n  (let [xs-at-pos (bytes-at-pos key-pos data)\n        _ (println xs-at-pos)]\n    ))&quot; &quot;(defn crack-p-at-pos [{:keys [data length magic] :as code-ref} key-pos]\n  (let [xs-at-pos (bytes-at-pos key-pos data)\n        _ (println xs-at-pos)\n        keys      (map #(take (inc (int (/ length 0xC))) %) (combinations 43))\n        _ (println (first keys))]\n    ))&quot; &quot;(defn crack-p-at-pos [{:keys [data length magic] :as code-ref} key-pos]\n  (let [xs-at-pos (bytes-at-pos key-pos data)\n        _ (println xs-at-pos)\n        keys      (map #(take (inc (int (/ length 0xC))) %) (combinations 43))\n        _ (println (first keys))\n        magic-at-pos (get key-pos magic)\n        _ (println magic-at-pos)]\n    ))&quot; &quot;(crack-p-at-pos p2 0)&quot; &quot;(defn crack-p-at-pos [{:keys [data length magic] :as code-ref} key-pos]\n  (let [xs-at-pos (bytes-at-pos key-pos data)\n        _ (println xs-at-pos)\n        keys      (map #(take (inc (int (/ length 0xC))) %) (combinations 43))\n        _ (println (first keys))\n        magic-at-pos (get  magic key-pos)\n        _ (println magic-at-pos)]\n    ))&quot; &quot;(magic-for-key-at-pos '(245 238 204) '(32 32 32 32))&quot; &quot;(crack-p-at-pos p0 0)&quot; &quot;0xf1&quot; &quot;(crack-p-at-pos p1 0)&quot; &quot;(def r2 (crack-p-at-pos p2 0))&quot; &quot;(def r0 (crack-p-at-pos p0 0))&quot; &quot;(count r2)&quot; &quot;(count r0)&quot; &quot;(repeat -1 2)&quot; &quot;(combinations 4 [[1 2 3]])&quot; &quot;(combinations 4 [[1 2 3] [4 5 6]])&quot; &quot;r0&quot; &quot;(crack-p-at-pos-with-hint p0 0 (map #(nth % 1) r0))&quot; &quot;(crack-p-at-pos-with-hint p1 0 (map #(nth % 1) r0))&quot; &quot;(defn magic-for-key-at-pos [xs-at-pos expanded-key]\n  (let [xorks-at-pos   (map xork expanded-key xs-at-pos)\n        computed-magic (reduce bit-xor 0 xorks-at-pos)]\n    (assert (= (count xs-at-pos) (count expanded-key) (count xorks-at-pos)))\n    [computed-magic expanded-key xs-at-pos xorks-at-pos]))&quot; &quot;(map = d08049210 d08050fa0 d08056100)&quot; &quot;(some true? (map = d08049210 d08050fa0))&quot; &quot;(map = d08049210 d08050fa0)&quot; &quot;(map = d08049210 d08056100)&quot; &quot;(some true? (map = d08049210 d08056100))&quot; &quot;(some true? (map = d08050fa0 d08056100))&quot; &quot;(filter #(true? (first %)) (map #(vector (= %1 %2) %1 %2) d08050fa0 d08056100))&quot; &quot;(filter #(true? (first %)) (map #(vector (= %1 %2) %1 %2 %3) d08049210 d08056100 (range)))&quot; &quot;(filter #(true? (first %)) (map #(vector (= %1 %2) %1 %2 %3) d08049210 d080 (range)))&quot; &quot;(filter #(true? (first %)) (map #(vector (= %1 %2) %1 %2 %3) d08049210 d08050fa0 (range)))&quot; &quot;(filter #(true? (first %)) (map #(vector (= %1 %2) %1 %2 %3) d08050fa0 d08056100 (range)))&quot; &quot;0x7D5C&quot; &quot;0x2D80&quot; &quot;0x24&quot; &quot;0x8949210 + 0x7D5C&quot; &quot;(+ 0x8949210 0x7D5C)&quot; &quot;0x08050fa0&quot; &quot;0x08050fa0 + 0x2D80&quot;], :remote []}}</component>
</project>