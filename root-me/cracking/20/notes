0xfffe9214 password
ecx = password
eax = len
suppression \n = 0

eop = 0x080562c0

|           0x080562c0 b  60             pushal
|           0x080562c1    81ec0c020000   sub esp, 0x20c // reserve une stack de 512 + 12 octet. 512 contient le mdp saisi, 12 contient ?
|           0x080562c7    89e6           mov esi, esp
|       ,=< 0x080562c9    e954010000     jmp 0x8056422                
|       |   ; CALL XREF from 0x08056422 (entry0)

Print password :
|       |   0x080562ce b  5f             pop edi
|       |   0x080562cf    b804000000     mov eax, 4
|       |   0x080562d4    bb01000000     mov ebx, 1
|       |   0x080562d9    683a200000     push 0x203a
|       |   0x080562de    68776f7264     push 0x64726f77
|       |   0x080562e3    6850617373     push 0x73736150
|       |   0x080562e8    89e1           mov ecx, esp
|       |   0x080562ea    ba0a000000     mov edx, 0xa
|       |   0x080562ef    cd80           int 0x80


Read passord (length 0xc) in 0xfffced64 (on stack):
;syscall[0xffffffff][-143058696]=? ; sym.imp._Jv_RegisterClasses
|       |   0x080562f1    83c40c         add esp, 0xc
|       |   0x080562f4    b803000000     mov eax, 3
|       |   0x080562f9    bb00000000     mov ebx, 0
|       |   0x080562fe    89f1           mov ecx, esi
|       |   0x08056300    ba00020000     mov edx, 0x200                ; 512
|       |   0x08056305    cd80           int 0x80 
;syscall[0xffffffff][-143058696]=? ; sym.imp._Jv_RegisterClasses
|       |   0x08056307 b  89f3           mov ebx, esi
|       |   0x08056309    01c3           add ebx, eax
|       |   0x0805630b    c643ff00       mov byte [ebx - 1], 0 // ecrase \n avec un 0

|    .----> 0x0805630f    833f00         cmp dword [edi], 0 // quand on a parcouru les 4 structures
|    | ,==< 0x08056312    743c           je 0x8056350

                 
edi est un pointeur de tableau vers une structure qui fait 20 (0x1C) bytes :
0ptrEncrypted = un tableau de taille sizeEncrypted
4sizeEncrypted = 
8checksum = check ptr encrypted with key is equal to checksum (taille= 12)
???

|    | ||   0x08056314    ff7704         push dword [edi + 4] // 0x7d5c
|    | ||   0x08056317    ff37           push dword [edi]  // 0x08049210
|    | ||   0x08056319    e83d000000     call 0x805635b  //xor - 0xaa sur 0x08049210 (cf bas)               
;entry0(unk, unk)


|    | ||   0x0805631e    81c600020000   add esi, 0x200 // esi = @password + 0x200
|    | ||   0x08056324    56             push esi // un buffer 
|    | ||   0x08056325    ff7704         push dword [edi + 4] // la taille du tableau
|    | ||   0x08056328    ff37           push dword [edi] // le tableau xoré
|    | ||   0x0805632a    e84f000000     call 0x805637e // réécriture à partir du xor

               
;entry0(unk, unk, unk)
|    | ||   0x0805632f    8d4708         lea eax, dword [edi + 8]       ; 
0x8  ; 8
|    | ||   0x08056332    50             push eax
|    | ||   0x08056333    56             push esi
|    | ||   0x08056334    e87a000000     call 0x80563b3   // verif             
;entry0(unk, unk)
|    | ||   0x08056339    83f800         cmp eax, 
|    |,===< 0x0805633c    0f84aa000000   je 0x80563ec  // go to Bad Password                
|    ||||   0x08056348    83c41c         add esp, 0x1c
|    ||||   0x0805634b    83c714         add edi, 0x14
|    `====< 0x0805634e    ebbf           jmp 0x805630f // do it again until edi = 0
               
|     |`--> 0x08056350    81c40c020000   add esp, 0x20c
|   ,=====< 0x08056356    e9c1000000     jmp 0x805641c                
|   `-----> 0x0805641c    61             popal
| ========< 0x0805641d    e95e36ffff     jmp 0x8049a80


///////////////////////////////////////////////////////////////
fonction de xor
//////////////////////////////////////////////////////////////

//////// CALL
            0x08056314    ff7704         push dword [edi + 4]                                         
|     | |   0x08056317    ff37           push dword [edi]                                             
|     | |   ;-- eip:                                                                                  
|     | |   0x08056319    e83d000000     call 0x805635b 

/////// FUNCTION

           0x0805635b    8b5c2404       mov ebx, dword [esp + 4]       ; [0x4:4]=-1 ; 4              
|           0x0805635f    8b442408       mov eax, dword [esp + 8]       ; [0x8:4]=-1 ; 8              
|           0x08056363    89f1           mov ecx, esi                                                 
ecx = password
eax = compteur
ebx = tableau à encoder
|     .---> 0x08056365    83f800         cmp eax, 0                                                   
|     | ,=< 0x08056368    7413           je 0x805637d                  ;[1]                           
|     | |   ;-- eip:                                                                                  
|     | |   0x0805636a    803900         cmp byte [ecx], 0                                            
|     |,==< 0x0805636d    7502           jne 0x8056371                 ;[2]                           
|     |||   0x0805636f    89f1           mov ecx, esi                                                 
|     |`--> 0x08056371    8a11           mov dl, byte [ecx]                                           
|     | |   0x08056373    3013           xor byte [ebx], dl                                           
|     | |   0x08056375    802baa         sub byte [ebx], 0xaa                                         
|     | |   0x08056378    48             dec eax                                                      
|     | |   0x08056379    43             inc ebx                                                      
|     | |   0x0805637a    41             inc ecx                                                      
|     `===< 0x0805637b    ebe8           jmp 0x8056365                 ;[3]  

////////// TRADUCTION

ebx = [0xe7, 0x6c, 0xcc, 0x6e....]
ecx = password
i = 0x7d5c
while i > 0:
  for c in ecx:
    ebx[i] = ebx[i] ^ ord(c)
    ebx[i] = ebx[i] - 0xaa
    i = i + 1


//////////////////////////////////////////////////////////
Fonction de recalcul
////////////////////////////////////////////////////////

//////// APPEL

|    | ||   0x0805631e    81c600020000   add esi, 0x200 // esi = @password + 0x200
|    | ||   0x08056324    56             push esi // un buffer 
|    | ||   0x08056325    ff7704         push dword [edi + 4] // la taille du tableau
|    | ||   0x08056328    ff37           push dword [edi] // le tableau xoré
|    | ||   0x0805632a    e84f000000     call 0x805637e // réécriture à partir du xor

////////// FONCTION

            0x0805637e    8b442404       mov eax, dword [esp + 4]       ; tableau xoré            
            0x08056382    8b5c2408       mov ebx, dword [esp + 8]       ; taille du tableau            
            0x08056386    8b4c240c       mov ecx, dword [esp + 0xc]     ; buffer         
// zeroes buffer
            0x0805638a    60             pushal                                                     
            0x0805638b    6a0c           push 0xc                      ; 12                         
            0x0805638d    51             push ecx                                                   
            0x0805638e    e844000000     call 0x80563d7                ;[1]                         
              ^- 0x080563d7(unk, unk, unk, unk) ; eip                                               
            0x08056393    83c408         add esp, 8                                                 
            0x08056396    61             popal                                                      

            0x08056397    31d2           xor edx, edx // edx = compteur du buffer                                              
// loop over xored array and compute magic number
      .---> 0x08056399    83fb00         cmp ebx, 0                                                 
      | ,=< 0x0805639c    7414           je 0x80563b2  // tant qu'on n'a pas parcouru le tableau en entier                        
      | |   0x0805639e    83fa0c         cmp edx, 0xc                  ; 12                         
      |,==< 0x080563a1    7502           jne 0x80563a5                 ;[3]                         
      |||   0x080563a3    31d2           xor edx, edx                                               

      |`--> 0x080563a5    60             pushal                                                     
      | |   0x080563a6    8a18           mov bl, byte [eax]                                         
      | |   0x080563a8    01ca           add edx, ecx                                               
      | |   0x080563aa    301a           xor byte [edx], bl // buffer[edx] = buffer[edx] ^ tab[eax]                                        
      | |   0x080563ac    61             popal                                                      

      | |   0x080563ad    42             inc edx                                                    
      | |   0x080563ae    40             inc eax                                                    
      | |   0x080563af    4b             dec ebx                                                    
      `===< 0x080563b0    ebe7           jmp 0x8056399                 ;[4]                         
        `-> 0x080563b2    c3             ret                                                        

1tab = [...cf ci dessus ...]
ecx = [0 0 0 0 0 0 0 0 0 0...] #0xC
ebx = 0x7d5c
while ebx > 0:
  for edx in range(0,0xc)
    f1 = f1tab[0x7d5c - ebx]
    ecx[edx] = ecx[edx] ^ f1

//////////////////////////////////////////////
check
/////////////////////////////////////////////

// CALL
       |    0x0805632f b  8d4708         lea eax, dword [edi + 8]       ; 0x8  ; 8                  
       |    0x08056332    50             push eax    // expected magic number                                               
       |    0x08056333    56             push esi    // actual magic number                                               
       |    0x08056334    e87a000000     call 0x80563b3                ;[1]

eax = 1 => OK
eax = 0 => KO

// function

     |   0x080563b3      8b5c2404       mov ebx, dword [esp + 4]  // juste computed magic 
        |   0x080563b7      8b4c2408       mov ecx, dword [esp + 8] // reference magic 
        |   0x080563bb      31d2           xor edx, edx                                                          
       .--> 0x080563bd      83fa0c         cmp edx, 0xc                ; 12                                      
      ,===< 0x080563c0      740f           je 0x80563d1                ;[1]                                      
      |||   0x080563c2      8a03           mov al, byte [ebx]                                                    
      |||   0x080563c4      3a01           cmp al, byte [ecx]                                                    
     ,====< 0x080563c6      7505           jne 0x80563cd               ;[2]                                      
     ||||   0x080563c8      43             inc ebx                                                               
     ||||   0x080563c9      41             inc ecx                                                               
     ||||   0x080563ca      42             inc edx                                                               
     ||`==< 0x080563cb      ebf0           jmp 0x80563bd               ;[3]                                      
     `----> 0x080563cd      31c0           xor eax, eax                                                          
      |,==< 0x080563cf      eb05           jmp 0x80563d6               ;[4]                                      
      `---> 0x080563d1      b801000000     mov eax, 1                                                            
       `--> 0x080563d6      c3             ret                                                                   

                         

//// code du jmp du début

            0x08056422      e8a7feffff     call 0x80562ce // routine de saisi mdp, calcul magic ...                             
            0x08056427      109204085c7d   adc byte [edx + 0x7d5c0804], dl                              
            0x0805642d      0000           add byte [eax], al                                           
            0x0805642f      35c940e297     xor eax, 0x97e240c9                                          
            0x08056434      de83533ab3dc   fiadd word [ebx - 0x234cc5ad]                                
            0x0805643a      98             cwde                                                         
            0x0805643b      a00f050880     mov al, byte [0x8008050f]   ; [0x8008050f:1]=255             
            0x08056440      2d00000fbb     sub eax, 0xbb0f0000                                          
            0x08056445      642d7f1272e4   sub eax, 0xe472127f                                          
            0x0805644b      c9             leave                                                        
            0x0805644c      3df6880061     cmp eax, 0x610088f6                                          
            0x08056451      0508240000     add eax, 0x2408                                              
            0x08056456      00f1           add cl, dh                                                   
            0x08056458      a104080101     mov eax, dword [0x1010804]  ; [0x1010804:4]=-1               
            0x0805645d      0000           add byte [eax], al                                           
            0x0805645f      9c             pushfd                                                       
            0x08056460      2505080000     and eax, 0x805                                               
            0x08056465      0000           add byte [eax], al    

#define _BUFFER_SIZE 280
unsigned char buffer[20 * 3] = {
  0x10, 0x92, 0x04, 0x08, 0x5c, //@= 0x8049210, l = 0x7d5c 
  0x7d, 0x00, 0x00, 0x35, 0xc9, 
  0x40, 0xe2, 0x97, 0xde, 0x83, 
  0x53, 0x3a, 0xb3, 0xdc, 0x98, // end 0 
  0xa0, 0x0f, 0x05, 0x08, 0x80, // @ = 0x08050fa0, l = 0x2d80 
  0x2d, 0x00, 0x00, 0x0f, 0xbb, 
  0x64, 0x2d, 0x7f, 0x12, 0x72, 
  0xe4, 0xc9, 0x3d, 0xf6, 0x88, // end 1 
  0x00, 0x61, 0x05, 0x08, 0x24, // @ = 0x08056100, l = 0x24 
  0x00, 0x00, 0x00, 0xf1, 0xa1, 
  0x04, 0x08, 0x01, 0x01, 0x00, 
  0x00, 0x9c, 0x25, 0x05, 0x08, // end 2 
}
